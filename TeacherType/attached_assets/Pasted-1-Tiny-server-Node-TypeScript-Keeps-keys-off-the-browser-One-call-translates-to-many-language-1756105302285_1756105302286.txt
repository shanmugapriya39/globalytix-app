1) Tiny server (Node + TypeScript)

Keeps keys off the browser. One call translates to many languages; another call does TTS per language.

Install

npm i express node-fetch express-rate-limit cors dotenv
npm i -D typescript @types/express @types/node ts-node


.env

PORT=8787
AZURE_REGION=<your-region>           # e.g. westeurope, uaenorth, eastus
TRANSLATOR_KEY=<your-translator-key>
SPEECH_KEY=<your-speech-key>


server.ts

import express from "express";
import fetch from "node-fetch";
import rateLimit from "express-rate-limit";
import cors from "cors";
import "dotenv/config";

const app = express();
app.use(cors());
app.use(express.json({ limit: "1mb" }));
app.use(rateLimit({ windowMs: 60_000, max: 120 }));

const { PORT = 8787, AZURE_REGION, TRANSLATOR_KEY, SPEECH_KEY } = process.env;
if (!AZURE_REGION || !TRANSLATOR_KEY || !SPEECH_KEY) {
  throw new Error("Missing env: AZURE_REGION, TRANSLATOR_KEY, SPEECH_KEY");
}

// Translate English -> many targets in one request
app.post("/translate", async (req, res) => {
  const { text, targetLangs } = req.body as { text: string; targetLangs: string[] };
  if (!text || !targetLangs?.length) return res.status(400).json({ error: "text/targetLangs required" });

  const qs = `api-version=3.0&from=en&` + targetLangs.map(l => `to=${encodeURIComponent(l)}`).join("&");
  const url = `https://api.cognitive.microsofttranslator.com/translate?${qs}`;

  const r = await fetch(url, {
    method: "POST",
    headers: {
      "Ocp-Apim-Subscription-Key": TRANSLATOR_KEY!,
      "Ocp-Apim-Subscription-Region": AZURE_REGION!,
      "Content-Type": "application/json"
    },
    body: JSON.stringify([{ Text: text.slice(0, 1000) }]) // cap length for latency
  });

  if (!r.ok) return res.status(502).json({ error: "translator failed", detail: await r.text() });
  const data = await r.json();
  res.json({ translations: data?.[0]?.translations ?? [] });
});

// TTS one language at a time (client throttles to 3 concurrent)
app.post("/tts", async (req, res) => {
  const { text, voice, locale } = req.body as { text: string; voice: string; locale: string };
  if (!text || !voice || !locale) return res.status(400).json({ error: "text/voice/locale required" });

  const ssml = `
<speak version='1.0' xml:lang='${locale}'>
  <voice name='${voice}'>
    <prosody rate='-10%'>${escapeXml(text)}</prosody>
  </voice>
</speak>`.trim();

  const url = `https://${AZURE_REGION}.tts.speech.microsoft.com/cognitiveservices/v1`;
  const r = await fetch(url, {
    method: "POST",
    headers: {
      "Ocp-Apim-Subscription-Key": SPEECH_KEY!,
      "Content-Type": "application/ssml+xml",
      "X-Microsoft-OutputFormat": "audio-24khz-48kbitrate-mono-mp3",
      "User-Agent": "TeacherTranslationApp"
    },
    body: ssml
  });

  if (!r.ok) return res.status(502).json({ error: "tts failed", detail: await r.text() });
  const buf = Buffer.from(await r.arrayBuffer());
  res.setHeader("Content-Type", "audio/mpeg");
  res.send(buf);
});

function escapeXml(s: string) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

app.listen(PORT, () => console.log(`API on :${PORT}`));

2) Language catalog (native labels + voices + RTL)

Use native names, not flags. Mark RTL for Arabic and Persian. Adjust voices if your Azure region differs.

languageCatalog.ts

export type Lang = {
  code: string;        // translator code
  ttsLocale: string;   // speech locale
  defaultVoice: string;
  uiLabel: string;     // native name
  rtl?: boolean;
};

export const LANGS: Lang[] = [
  { code: "ar",      ttsLocale: "ar-EG", defaultVoice: "ar-EG-SalmaNeural", uiLabel: "العربية", rtl: true },
  { code: "es",      ttsLocale: "es-ES", defaultVoice: "es-ES-AlvaroNeural", uiLabel: "Español" },
  { code: "fr",      ttsLocale: "fr-FR", defaultVoice: "fr-FR-DeniseNeural", uiLabel: "Français" },
  { code: "ru",      ttsLocale: "ru-RU", defaultVoice: "ru-RU-DmitryNeural", uiLabel: "Русский" },
  { code: "pt",      ttsLocale: "pt-BR", defaultVoice: "pt-BR-AntonioNeural", uiLabel: "Português" },
  { code: "tr",      ttsLocale: "tr-TR", defaultVoice: "tr-TR-AhmetNeural", uiLabel: "Türkçe" },
  { code: "it",      ttsLocale: "it-IT", defaultVoice: "it-IT-IsabellaNeural", uiLabel: "Italiano" },
  { code: "nl",      ttsLocale: "nl-NL", defaultVoice: "nl-NL-MaartenNeural", uiLabel: "Nederlands" },
  { code: "da",      ttsLocale: "da-DK", defaultVoice: "da-DK-ChristelNeural", uiLabel: "Dansk" },
  { code: "zh-Hans", ttsLocale: "zh-CN", defaultVoice: "zh-CN-XiaoxiaoNeural", uiLabel: "中文（简体）" },
  { code: "fa",      ttsLocale: "fa-IR", defaultVoice: "fa-IR-DilaraNeural", uiLabel: "فارسی", rtl: true },
  { code: "lv",      ttsLocale: "lv-LV", defaultVoice: "lv-LV-EveritaNeural", uiLabel: "Latviešu" }
];

3) Client wiring (React + TS)

One call for all translations.

TTS generated in parallel with a 3-at-a-time limiter to avoid throttling.

Proper RTL containers.

“Generate Audio” returns audio blobs and offers a Zip export.

Install

npm i jszip file-saver qrcode


api.ts

export async function translateMany(text: string, targets: string[]) {
  const r = await fetch("/translate", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text, targetLangs: targets })
  });
  if (!r.ok) throw new Error(await r.text());
  return (await r.json()).translations as { to: string; text: string }[];
}

function limiter(limit = 3) {
  let active = 0, q: (() => void)[] = [];
  return <T>(fn: () => Promise<T>) =>
    new Promise<T>((resolve, reject) => {
      const run = async () => {
        active++;
        try { resolve(await fn()); }
        catch (e) { reject(e); }
        finally { active--; q.shift()?.(); }
      };
      active < limit ? run() : q.push(run);
    });
}
const runLimited = limiter(3);

export async function tts(text: string, voice: string, locale: string) {
  const r = await runLimited(() => fetch("/tts", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text, voice, locale })
  }));
  if (!r.ok) throw new Error(await r.text());
  return await r.blob(); // audio/mpeg
}


TranslationPanel.tsx (core UI)

import React, { useMemo, useState } from "react";
import { LANGS } from "./languageCatalog";
import { translateMany, tts } from "./api";
import JSZip from "jszip";
import { saveAs } from "file-saver";

type Sel = { code: string; ttsLocale: string; voice: string; uiLabel: string; rtl?: boolean };

export default function TranslationPanel() {
  const [selected, setSelected] = useState<Sel[]>([]);
  const [text, setText] = useState("");
  const [busy, setBusy] = useState(false);
  const [progress, setProgress] = useState<{ done: number; total: number }>({ done: 0, total: 0 });
  const max = 12;

  const canRun = text.trim().length > 0 && selected.length > 0 && !busy;

  function toggle(lang: Sel) {
    setSelected(prev => {
      const exists = prev.some(p => p.code === lang.code);
      if (exists) return prev.filter(p => p.code !== lang.code);
      if (prev.length >= max) return prev; // no more than 12
      return [...prev, lang];
    });
  }

  async function handleGenerate() {
    try {
      setBusy(true); setProgress({ done: 0, total: 0 });
      const targets = selected.map(s => s.code);
      const translations = await translateMany(text.trim(), targets);

      const total = translations.length;
      setProgress({ done: 0, total });

      // Build UI objects in selection order
      const ordered = selected.map(sel => {
        const t = translations.find(x => x.to === sel.code)!;
        return { sel, translated: t?.text || "" };
      });

      // Play/Export pipeline: generate audio files
      const zip = new JSZip();
      let done = 0;
      for (const item of ordered) {
        const audio = await tts(item.translated, item.sel.voice, item.sel.ttsLocale);
        const fname = `${item.sel.uiLabel}-${Date.now()}.mp3`;
        zip.file(fname, audio);
        setProgress({ done: ++done, total });
      }

      const blob = await zip.generateAsync({ type: "blob" });
      saveAs(blob, "TeacherTranslations.zip");
    } catch (e: any) {
      alert("Error: " + (e?.message || e));
    } finally {
      setBusy(false);
    }
  }

  const selectedCount = selected.length;
  const languages = useMemo(() =>
    LANGS.map(l => ({ code: l.code, ttsLocale: l.ttsLocale, voice: l.defaultVoice, uiLabel: l.uiLabel, rtl: l.rtl })), []);

  return (
    <div className="panel">
      <h2>English → Languages</h2>

      <p className="hint">Select Target Languages (up to {max})</p>
      <div className="grid">
        {languages.map(l => {
          const on = selected.some(s => s.code === l.code);
          return (
            <button
              key={l.code}
              className={`pill ${on ? "on" : ""}`}
              onClick={() => toggle(l)}
              dir={l.rtl ? "rtl" : "ltr"}
              aria-pressed={on}
            >
              {l.rtl ? `(${l.uiLabel})` : l.uiLabel}
            </button>
          );
        })}
      </div>

      <label className="label">English Text to Translate</label>
      <textarea
        value={text}
        onChange={e => setText(e.target.value)}
        placeholder="Type your English message here…"
        rows={4}
        aria-label="English text to translate"
      />

      <div className="footer">
        <span>{selectedCount} languages selected</span>
        <button className="primary" disabled={!canRun} onClick={handleGenerate}>
          {busy ? `Generating ${progress.done}/${progress.total}` : "Generate Audio"}
        </button>
      </div>
    </div>
  );
}


CSS essentials (readability + script coverage)

/* index.css */
:root { --radius: 12px; --bg:#f6f8fb; --ink:#0f172a; }
body { font-family: "Noto Sans", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: var(--ink); background: var(--bg); }
.panel { background:#fff; padding:24px; border-radius:20px; box-shadow:0 1px 8px rgba(0,0,0,.06); max-width: 860px; margin: 24px auto; }
h2 { margin: 0 0 8px; font-size: 24px; }
.hint { color:#475569; margin: 0 0 8px; }
.grid { display:grid; grid-template-columns: repeat(3,minmax(0,1fr)); gap:10px; margin-bottom:12px; }
.pill { padding:12px 14px; background:#f1f5f9; border:1px solid #e2e8f0; border-radius:999px; cursor:pointer; text-align:center; font-size:16px; }
.pill.on { background:#e0f2fe; border-color:#38bdf8; }
.label { display:block; margin: 12px 0 6px; font-weight:600; }
textarea { width:100%; padding:12px; border:1px solid #e2e8f0; border-radius:12px; font-size:16px; line-height:1.5; }
.footer { margin-top:12px; display:flex; justify-content:space-between; align-items:center; }
.primary { padding:12px 16px; border-radius:999px; background:#166534; color:#fff; border:none; cursor:pointer; }
.primary:disabled { opacity:.5; cursor:not-allowed; }

/* Stronger CJK/Arabic rendering if you include extra fonts: */
.rtl { direction: rtl; }


For better Arabic/CJK coverage, include the Google “Noto” families (Noto Sans, Noto Naskh Arabic, Noto Sans SC). Even without custom fonts, the dir attribute we set per pill handles text direction.

EAL/ELL details you should not skip

Readability: base 18px, high contrast, ample spacing. Your screenshot is close—keep it that way.

RTL: set dir="rtl" on any Arabic/Persian container (I did this on each pill; also do it in the translation output if you render text there later).

No flags: use native names only.

Latency: keep the translation text under ~1k chars per call; split long paragraphs into sentences if needed.

Concurrency: TTS is limited to 3 at a time — avoids throttling and UI lockups.

Export: I zip all MP3s automatically. Teachers love “one click, one file.”

Audio UX: if you want in-page playback before export, add a small list that shows each language, the translated text, and a play button.

Accessibility: buttons have aria-pressed; the main textarea has an accessible label. Keep that pattern.

Common pitfalls I’ve already eliminated

Vendor keys in the browser — they’re on the server.

Translating one language at a time — I call multi-target once.

RTL punctuation mess — dir="rtl" on the element.

Rate limiting — client-side concurrency limiter.

Export friction — bundled zip after generation.